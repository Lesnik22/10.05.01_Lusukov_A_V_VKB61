# Документация проекта: Безопасная корпоративная система обмена файлами

**Версия:** 2.0  
**Дата:** 2026  
**Описание:** Полная документация системы безопасного обмена файлами с MFA, RBAC, шифрованием и интеграцией VirusTotal

---

## Оглавление

1. [Общее описание](#1-общее-описание)
2. [Безопасность](#2-безопасность)
3. [Технологии](#3-технологии)
4. [Логика работы системы](#4-логика-работы-системы)
5. [Шифрование](#5-шифрование)
6. [Доступ к файлам и права](#6-доступ-к-файлам-и-права)
7. [Ролевая политика (RBAC)](#7-ролевая-политика-rbac)
8. [Многофакторная аутентификация (MFA)](#8-многофакторная-аутентификация-mfa)
9. [Архитектура базы данных](#9-архитектура-базы-данных)
10. [Интеграция VirusTotal](#10-интеграция-virustotal)
11. [Аудит и логирование](#11-аудит-и-логирование)
12. [Администрирование](#12-администрирование)

---

## 1. Общее описание

Безопасная корпоративная система обмена файлами — это веб-приложение для безопасного хранения, передачи и управления файлами в корпоративной среде.

### Основные возможности:

- ✅ **Безопасная загрузка и хранение файлов** с шифрованием на уровне диска
- ✅ **Многофакторная аутентификация (MFA)** через TOTP
- ✅ **Ролевая модель доступа (RBAC)** с гибкой системой разрешений
- ✅ **Контроль доступа к файлам** на уровне отделов и пользователей
- ✅ **Интеграция с VirusTotal** для проверки файлов на вирусы
- ✅ **Полное логирование действий** и событий безопасности
- ✅ **Админ-панель** для управления пользователями, ролями и отделами
- ✅ **Управление отделами** с поддержкой иерархической структуры
- ✅ **Политики обмена файлами** между отделами
- ✅ **Защита от брутфорс-атак** и подозрительной активности

---

## 2. Безопасность

### 2.1 Многоуровневая защита

Система использует многоуровневый подход к безопасности:

#### Аутентификация
- **Хеширование паролей**: Используется `bcrypt` с автоматической генерацией соли
- **MFA (TOTP)**: Обязательная или опциональная двухфакторная аутентификация через приложения типа Google Authenticator
- **Защита сессий**: Уникальные session ID, отслеживание IP-адресов и User-Agent

#### Авторизация
- **RBAC**: Ролевая модель доступа с гранулярными разрешениями
- **Проверка прав доступа**: На уровне файлов, отделов и пользователей
- **Политики обмена**: Контроль передачи файлов между отделами

#### Защита данных
- **Шифрование файлов**: Все файлы шифруются перед сохранением (ГОСТ 34.12-2015 "Кузнечик")
- **Шифрование ключей**: Ключи файлов шифруются мастер-ключом
- **Безопасное хранение**: Ключи хранятся отдельно от данных

### 2.2 Защита от атак

#### Защита от брутфорс-атак
- **Лимит попыток входа**: Настраиваемое количество неудачных попыток (по умолчанию 5)
- **Временная блокировка**: Блокировка IP и учетной записи на определенное время (по умолчанию 15 минут)
- **Отслеживание попыток**: Все попытки входа логируются в таблицу `LoginAttempt`

#### Защита от вредоносного ПО
- **VirusTotal интеграция**: Автоматическая проверка всех загружаемых файлов
- **Блокировка опасных файлов**: Файлы с статусом `malicious` не могут быть скачаны
- **Ожидание проверки**: Файлы со статусом `pending` временно недоступны для скачивания

#### Мониторинг безопасности
- **События безопасности**: Все подозрительные действия логируются в `SecurityEvent`
- **Автоматические алерты**: Настраиваемые правила для уведомления администраторов
- **Отслеживание инцидентов**: Группировка связанных событий в инциденты

### 2.3 Аудит и отслеживание

- **Журнал действий**: Все действия пользователей записываются в `AuditLog`
- **Журнал конфигурации**: Изменения настроек логируются в `ConfigChangeLog`
- **Логирование в файлы**: Дополнительное логирование в JSON-формате
- **Отслеживание сессий**: Учет активных сессий пользователей в `UserSession`

### 2.4 Защита транспортного уровня (TLS/HTTPS)

Система может работать по HTTPS (HTTP over TLS), чтобы **весь трафик** (включая передачу файлов, куки сессии и учетные данные) был защищен от перехвата/подмены в локальной сети.

#### Локальная сеть / доступ по IP (DEV)

Для локальной сети поддержан “встроенный” HTTPS в режиме разработки (самоподписанный сертификат):

- **Переменные** (можно задать в `KEY.env`):
  - `ENABLE_TLS=1` — включить HTTPS
  - `TLS_CERT_PATH=certs/dev-cert.pem` — путь к сертификату
  - `TLS_KEY_PATH=certs/dev-key.pem` — путь к ключу

- **Генерация DEV-сертификата под IP**:
  - Скрипт: `scripts/generate_dev_tls_cert.py`
  - Команда: `python scripts/generate_dev_tls_cert.py --ip <ваш_ip>`

- **Открытие в браузере**:
  - `https://<ваш_ip>:5000/`

Примечание: браузер будет показывать предупреждение безопасности (самоподписанный сертификат).

#### Продакшен

Для продакшена рекомендуется завершать TLS на уровне reverse proxy (Nginx/Caddy/Traefik) и проксировать запросы на WSGI-сервер (Gunicorn/uWSGI). Это повышает надежность и дает нормальную работу сертификатов (например, Let’s Encrypt).

---

## 3. Технологии

### 3.1 Backend

| Технология | Версия | Назначение |
|------------|--------|------------|
| **Python** | 3.8+ | Язык программирования |
| **Flask** | 2.3.3+ | Веб-фреймворк |
| **SQLAlchemy** | 3.0.5+ | ORM для работы с БД |
| **Flask-Login** | 0.6.3+ | Управление пользовательскими сессиями |
| **Werkzeug** | - | Хеширование паролей и утилиты |
| **Cryptography** | 41.0.4+ | Базовые криптографические примитивы |
| **gost_crypto** | - | Реализация ГОСТ 34.12-2015 "Кузнечик" |
| **bcrypt** | - | Хеширование паролей |
| **PyOTP** | 2.8.0+ | Генерация TOTP кодов для MFA |
| **QRCode** | 7.4.2+ | Генерация QR-кодов для настройки MFA |
| **Requests** | - | HTTP-запросы к VirusTotal API |

### 3.2 Frontend

| Технология | Назначение |
|------------|------------|
| **HTML5** | Разметка страниц |
| **CSS3 / Bootstrap 5** | Стилизация и адаптивный дизайн |
| **Jinja2** | Шаблонизация (встроена в Flask) |
| **JavaScript** | Динамическое поведение интерфейса |
| **Font Awesome** | Иконки |

### 3.3 База данных

- **SQLite** (по умолчанию) или **PostgreSQL/MySQL** через SQLAlchemy
- **Миграции**: Поддержка миграций через функции миграции

### 3.4 Хранение файлов

- **Файловая система**: Зашифрованные файлы хранятся в директории `uploads/`
- **Метаданные**: Информация о файлах хранится в БД

---

## 4. Логика работы системы

### 4.1 Общий workflow

```
1. Пользователь регистрируется → Статус "pending"
2. Администратор одобряет → Статус "active"
3. Пользователь настраивает MFA (если требуется)
4. Пользователь входит в систему (логин + пароль + MFA)
5. Пользователь загружает файл:
   - Файл сохраняется во временное хранилище
   - Вычисляется SHA-256 хеш
   - Файл отправляется в VirusTotal
   - Генерируется уникальный ключ шифрования
   - Файл шифруется
   - Ключ шифруется мастер-ключом
   - Метаданные сохраняются в БД
6. Другой пользователь запрашивает доступ к файлу
7. Система проверяет права доступа:
   - Явный доступ (FileAccess)
   - Уровень доступа файла (private/department/public)
   - Политики обмена между отделами
   - Роль администратора
8. Если доступ разрешен → Файл расшифровывается и отдается
```

### 4.2 Процесс загрузки файла

1. **Валидация файла**
   - Проверка размера (максимум 300 МБ)
   - Проверка типа файла
   - Проверка имени файла (sanitization)

2. **Вычисление хеша**
   - SHA-256 хеш вычисляется для идентификации файла
   - Используется для проверки в VirusTotal

3. **Проверка VirusTotal**
   - Если файл уже проверялся (хеш в кэше) → используется кэш
   - Иначе → отправляется запрос в VirusTotal API
   - Статус сохраняется: `pending`, `clean`, `malicious`, `failed`, `skipped`, `unscanned`

4. **Шифрование**
   - Генерируется уникальный ключ для файла
   - Файл шифруется с помощью ГОСТ 34.12-2015 "Кузнечик"
   - Зашифрованный файл сохраняется на диск

5. **Сохранение ключа**
   - Ключ файла шифруется мастер-ключом
   - Зашифрованный ключ сохраняется в таблице `EncryptionKey`

6. **Создание записи**
   - Метаданные файла сохраняются в таблицу `File`
   - Связь с ключом шифрования устанавливается через `encryption_key_id`

### 4.3 Процесс скачивания файла

1. **Проверка прав доступа**
   - Владелец файла?
   - Явный доступ через `FileAccess`?
   - Уровень доступа файла (private/department/public)?
   - Политика обмена между отделами?
   - Администратор? (имеет доступ ко всем файлам)

2. **Проверка VirusTotal**
   - Если статус `pending` → попытка обновления статуса
   - Если статус `malicious` → доступ запрещен
   - Если статус `pending/failed/skipped/unscanned` → доступ временно запрещен
   - Только статус `clean` → доступ разрешен

3. **Расшифровка**
   - Получение зашифрованного ключа из `EncryptionKey`
   - Расшифровка ключа мастер-ключом
   - Расшифровка файла
   - Отдача файла пользователю

4. **Логирование**
   - Запись действия в `AuditLog`
   - Обновление времени последнего доступа (если требуется)

### 4.4 Часовой пояс

Система использует **московское время (UTC+3)** для всех записей времени:
- `created_at`, `updated_at`, `timestamp` — все используют `moscow_now()`
- Функция `moscow_now()` возвращает текущее время с часовым поясом UTC+3

---

## 5. Шифрование

### 5.1 Архитектура шифрования

Система использует **двухуровневое шифрование**:

```
┌─────────────────────────────────────────┐
│  Файл (незашифрованный)                 │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Генерация уникального ключа (ГОСТ)     │
│  для каждого файла                      │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Файл зашифрован ключом файла           │
│  → Сохранение на диск                   │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  Ключ файла (незашифрованный)           │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Шифрование мастер-ключом (ГОСТ)       │
│  Мастер-ключ хранится в KEY.env         │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│  Зашифрованный ключ → EncryptionKey     │
│  таблица в БД                           │
└─────────────────────────────────────────┘
```

### 5.2 Алгоритмы шифрования

#### ГОСТ 34.12-2015 "Кузнечик" (GOST Kuznyechik)
- **Алгоритм**: ГОСТ 34.12-2015 "Кузнечик" - блочный шифр
- **Размер блока**: 128 бит (16 байт)
- **Размер ключа**: 256 бит (32 байта)
- **Количество раундов**: 10
- **Режим**: CBC (Cipher Block Chaining)
- **Библиотека**: `gost_crypto.GOSTKuznyechik`
- **Применение**: 
  - Шифрование файлов
  - Шифрование ключей файлов
- **Стандарт**: Полное соответствие российскому стандарту ГОСТ Р 34.12-2015
- **Реализация**: 
  - Полная реализация алгоритма с S-преобразованием и L-преобразованием
  - Генерация раундовых ключей по стандарту
  - 10 раундов шифрования/расшифровки
  - Режим CBC с правильной реализацией

#### Мастер-ключ
- **Хранение**: В файле `KEY.env` (переменная `ENCRYPTION_KEY`)
- **Формат**: Base64-encoded ключ ГОСТ (32 байта для Кузнечика)
- **Генерация**: `GOSTKuznyechik.generate_key()`
- **Важно**: Мастер-ключ должен быть постоянным, иначе ранее зашифрованные файлы не смогут быть расшифрованы

### 5.3 Процесс шифрования файла

```python
# 1. Генерация уникального ключа для файла (ГОСТ 34.12-2015 Кузнечик)
data_key = GOSTKuznyechik.generate_key()  # 32 байта (256 бит)

# 2. Создание cipher объекта
cipher = GOSTKuznyechik(data_key)

# 3. Чтение файла
with open(file_path, 'rb') as file:
    file_data = file.read()

# 4. Шифрование алгоритмом ГОСТ "Кузнечик" в режиме CBC
encrypted_data = cipher.encrypt(file_data)

# 5. Сохранение зашифрованного файла
with open(file_path, 'wb') as file:
    file.write(encrypted_data)
```

### 5.4 Процесс шифрования ключа файла

```python
# 1. Загрузка мастер-ключа из переменных окружения
master_key_base64 = os.environ.get('ENCRYPTION_KEY')
master_key = GOSTKuznyechik.key_from_base64(master_key_base64)
cipher_suite = GOSTKuznyechik(master_key)

# 2. Шифрование ключа файла мастер-ключом (ГОСТ "Кузнечик")
encrypted_key = cipher_suite.encrypt(data_key)

# 3. Сохранение в БД
key_record = EncryptionKey(
    scope='file',
    ref_id=file_id,
    encrypted_key=encrypted_key
)
```

### 5.5 Процесс расшифровки

```python
# 1. Получение зашифрованного ключа из БД
encrypted_key = file_obj.encryption_key.encrypted_key

# 2. Расшифровка ключа мастер-ключом (ГОСТ "Кузнечик")
data_key = cipher_suite.decrypt(encrypted_key)

# 3. Создание cipher объекта для файла
cipher = GOSTKuznyechik(data_key)

# 4. Чтение зашифрованного файла
with open(file_path, 'rb') as file:
    encrypted_data = file.read()

# 5. Расшифровка алгоритмом ГОСТ "Кузнечик"
decrypted_data = cipher.decrypt(encrypted_data)
```

### 5.6 Модель EncryptionKey

| Поле | Тип | Описание |
|------|-----|----------|
| `id` | Integer | Уникальный идентификатор |
| `scope` | String(20) | Область применения (обычно 'file') |
| `ref_id` | Integer | ID связанного ресурса (ID файла) |
| `encrypted_key` | LargeBinary | Зашифрованный ключ файла |
| `created_at` | DateTime | Время создания (МСК) |
| `rotated_at` | DateTime | Время ротации ключа (если было) |

### 5.7 Безопасность ключей

- **Изоляция**: Каждый файл имеет уникальный ключ
- **Шифрование ключей**: Ключи файлов никогда не хранятся в открытом виде
- **Мастер-ключ**: Хранится в переменных окружения, не в коде
- **Ротация**: Поддержка ротации ключей (поле `rotated_at`)
- **Потеря ключа**: Если мастер-ключ утерян, все файлы становятся недоступными

---

## 6. Доступ к файлам и права

### 6.1 Уровни доступа к файлам

Система поддерживает **три уровня доступа**:

#### 1. Private (Приватный)
- **Описание**: Файл доступен только владельцу
- **Исключения**: 
  - Явный доступ через `FileAccess`
  - Администраторы имеют доступ ко всем файлам

#### 2. Department (Отдел)
- **Описание**: Файл доступен всем пользователям того же отдела
- **Дополнительно**: 
  - Проверяются политики обмена между отделами (`ExchangePolicy`)
  - Если политика запрещает обмен, доступ блокируется

#### 3. Public (Публичный)
- **Описание**: Файл доступен всем пользователям системы
- **Ограничения**: 
  - Все еще требуются права `download_files`
  - Проверяются политики обмена (если отделы указаны)

### 6.2 Модель FileAccess

**Явное предоставление доступа** к файлу конкретному пользователю:

| Поле | Тип | Описание |
|------|-----|----------|
| `id` | Integer | Уникальный идентификатор |
| `file_id` | Integer | ID файла (FK → File) |
| `user_id` | Integer | ID пользователя (FK → User) |
| `permission` | String(20) | Тип доступа: 'read', 'write', 'admin' |
| `granted_by` | Integer | ID пользователя, предоставившего доступ |
| `granted_at` | DateTime | Время предоставления (МСК) |
| `expires_at` | DateTime | Время истечения доступа (опционально) |

**Типы разрешений:**
- `read` — только чтение/скачивание
- `write` — возможность редактирования (зарезервировано)
- `admin` — полный контроль над файлом (зарезервировано)

### 6.3 Алгоритм проверки доступа

При запросе на скачивание файла система проверяет доступ в следующем порядке:

```python
def check_file_access(file, user):
    # 1. Администратор имеет доступ ко всем файлам
    if user.role.has_permission('admin_access'):
        return True
    
    # 2. Владелец файла всегда имеет доступ
    if file.owner_id == user.id:
        return True
    
    # 3. Проверка явного доступа через FileAccess
    if FileAccess.query.filter_by(file_id=file.id, user_id=user.id).first():
        # Проверка срока действия
        if access.expires_at and access.expires_at < moscow_now():
            return False
        return True
    
    # 4. Проверка уровня доступа файла
    if file.access_level == 'public':
        if not is_view_allowed(file, user):  # Проверка политик обмена
            return False
        return True
    
    if file.access_level == 'department':
        # Проверка принадлежности к отделу
        if file.department_id and user.department_id:
            if file.department_id == user.department_id:
                if not is_view_allowed(file, user):  # Проверка политик обмена
                    return False
                return True
    
    # 5. Private файлы недоступны
    return False
```

### 6.4 Политики обмена между отделами (ExchangePolicy)

Система позволяет настраивать правила обмена файлами между отделами:

| Поле | Тип | Описание |
|------|-----|----------|
| `id` | Integer | Уникальный идентификатор |
| `source_department_id` | Integer | ID отдела-источника (FK → Department) |
| `target_department_id` | Integer | ID отдела-получателя (FK → Department) |
| `action` | String(20) | Тип действия: 'send' или 'view' |
| `allow` | Boolean | Разрешить (True) или запретить (False) |
| `created_by` | Integer | ID администратора, создавшего политику |
| `created_at` | DateTime | Время создания (МСК) |

**Типы действий:**
- `send` — отправка файлов из одного отдела в другой
- `view` — просмотр файлов другого отдела

**Логика работы:**
- Если политика явно разрешает (`allow=True`) → доступ разрешен
- Если политика явно запрещает (`allow=False`) → доступ запрещен
- Если политики нет → доступ **запрещен по умолчанию** (безопасная политика)

**Примеры:**

| Источник | Получатель | Действие | Разрешить | Результат |
|----------|------------|----------|-----------|-----------|
| IT | HR | view | True | HR может видеть файлы IT |
| IT | HR | send | False | IT не может отправлять файлы в HR |
| Finance | - | view | True | Все могут видеть файлы Finance |

### 6.5 Модель File

Основная модель файла содержит информацию о доступе:

| Поле | Тип | Описание |
|------|-----|----------|
| `id` | Integer | Уникальный идентификатор |
| `filename` | String(255) | Имя файла на диске |
| `original_filename` | String(255) | Оригинальное имя файла |
| `file_path` | String(500) | Путь к зашифрованному файлу |
| `file_size` | Integer | Размер файла в байтах |
| `mime_type` | String(100) | MIME-тип файла |
| `encrypted` | Boolean | Флаг шифрования (всегда True) |
| `owner_id` | Integer | ID владельца (FK → User) |
| `access_level` | String(20) | Уровень доступа: 'private', 'department', 'public' |
| `department_id` | Integer | ID отдела (FK → Department, nullable) |
| `created_at` | DateTime | Время загрузки (МСК) |
| `encryption_key_id` | Integer | ID ключа шифрования (FK → EncryptionKey) |
| `vt_status` | String(20) | Статус проверки VirusTotal |
| `vt_checked_at` | DateTime | Время последней проверки VirusTotal |
| `vt_detection_count` | Integer | Количество обнаружений в VirusTotal |
| `vt_permalink` | String(500) | Ссылка на отчет VirusTotal |

---

## 7. Ролевая политика (RBAC)

### 7.1 Концепция RBAC

**Role-Based Access Control (RBAC)** — ролевая модель доступа, где права предоставляются через роли, а не напрямую пользователям.

```
Пользователь → Роль → Разрешения → Действия
```

### 7.2 Модель Role

| Поле | Тип | Описание |
|------|-----|----------|
| `id` | Integer | Уникальный идентификатор |
| `name` | String(50) | Название роли (unique) |
| `description` | String(200) | Описание роли |
| `permissions` | Text | JSON-строка со списком разрешений |

**Метод:**
```python
def has_permission(self, permission):
    """Проверяет наличие разрешения у роли"""
    perms = json.loads(self.permissions or '[]')
    return permission in perms
```

### 7.3 Каталог разрешений

Система определяет следующие разрешения:

| Разрешение | Описание |
|------------|----------|
| `admin_access` | Доступ к админ-панели |
| `manage_users` | Управление пользователями (создание, редактирование, блокировка) |
| `manage_roles` | Управление ролями и правами |
| `manage_departments` | Управление отделами |
| `manage_exchange_policies` | Управление политиками обмена файлами между отделами |
| `manage_force_mfa` | Принудительное включение MFA для всех пользователей |
| `manage_department_users` | Управление пользователями своего отдела (для руководителей) |
| `view_audit` | Просмотр журнала аудита |
| `view_security_events` | Просмотр событий безопасности |
| `upload_files` | Загрузка файлов |
| `download_files` | Скачивание файлов |
| `share_files` | Предоставление доступа к файлам |

### 7.4 Роли по умолчанию

#### Admin (Администратор)
**Разрешения:**
- Все разрешения из каталога
- Полный доступ ко всем файлам (даже private)
- Управление системой

#### Manager (Менеджер)
**Разрешения:**
- `upload_files`
- `download_files`
- `share_files`
- `manage_department_users` (если назначен руководителем отдела)
- `view_audit` (опционально)

#### User (Пользователь)
**Разрешения:**
- `upload_files`
- `download_files`
- `share_files`

### 7.5 Проверка разрешений в коде

#### Декоратор `@role_required`
```python
@role_required('admin_access')
def admin_panel():
    # Только пользователи с разрешением 'admin_access'
    # могут получить доступ к этой функции
    pass
```

**Как работает:**
1. Проверяет аутентификацию пользователя
2. Проверяет наличие разрешения у роли пользователя
3. Если разрешения нет → перенаправление на dashboard с сообщением об ошибке

#### Прямая проверка в коде
```python
if current_user.role.has_permission('manage_users'):
    # Разрешить действие
    pass
else:
    # Запретить действие
    flash('У вас нет прав для выполнения этого действия', 'error')
```

### 7.6 Руководители отделов

Пользователь может быть назначен **руководителем отдела** через поле `managed_department_id`:

**Возможности руководителя:**
- Просмотр всех пользователей своего отдела
- Изменение ролей пользователей (кроме 'admin')
- Включение/выключение пользователей
- Сброс MFA для пользователей отдела

**Ограничения:**
- Не может управлять пользователями других отделов
- Не может назначать роль 'admin'
- Не может изменять статус администраторов

### 7.7 Динамическое управление ролями

Роли и разрешения можно изменять в админ-панели:
- Добавление/удаление разрешений из роли
- Создание новых ролей
- Изменение описаний ролей
- Все изменения логируются в `ConfigChangeLog`

---

## 8. Многофакторная аутентификация (MFA)

### 8.1 Обзор MFA

MFA добавляет второй уровень защиты к стандартной аутентификации (логин + пароль).

**Используемый стандарт:** TOTP (Time-based One-Time Password) — RFC 6238

**Совместимые приложения:**
- Google Authenticator
- Microsoft Authenticator
- Authy
- Любое TOTP-совместимое приложение

### 8.2 Процесс настройки MFA

1. **Пользователь заходит на `/setup_mfa`**
2. **Генерация секрета**
   - Генерируется случайный 32-символьный base32 секрет
   - Сохраняется в `user.mfa_secret`

3. **Создание QR-кода**
   - Формируется provisioning URI: `otpauth://totp/...`
   - Генерируется QR-код с использованием библиотеки `qrcode`
   - QR-код отображается пользователю

4. **Сканирование QR-кода**
   - Пользователь сканирует QR-код в приложении аутентификатора
   - Приложение начинает генерировать 6-значные коды каждые 30 секунд

5. **Подтверждение настройки**
   - Пользователь вводит код из приложения
   - Система проверяет код через `pyotp.TOTP(secret).verify(code)`
   - Если код верен → `mfa_enabled = True`

### 8.3 Процесс входа с MFA

1. **Ввод логина и пароля**
   - Проверка учетных данных
   - Если верны → переход к MFA

2. **Проверка MFA**
   - Если `user.mfa_enabled == True` → перенаправление на `/mfa_verify/<user_id>`
   - Пользователь вводит 6-значный код из приложения

3. **Верификация кода**
   - Код проверяется через `pyotp.TOTP(user.mfa_secret).verify(code)`
   - Учитывается допустимое отклонение времени (±1 период = 30 секунд)

4. **Успешный вход**
   - Создание сессии
   - Запись в `AuditLog`
   - Перенаправление на dashboard

### 8.4 Принудительное MFA

Администратор может включить **принудительное MFA** для всех пользователей:

**Настройка:** `Settings.force_mfa = True`

**Последствия:**
- Новые пользователи должны настроить MFA перед первым входом
- Существующие пользователи получают предупреждение
- Можно переопределить для конкретного пользователя через `force_mfa_override`

### 8.5 Сброс MFA

**Кто может сбросить:**
- Сам пользователь (если MFA включен)
- Администратор
- Руководитель отдела (для пользователей своего отдела)

**Процесс сброса:**
- `mfa_enabled = False`
- `mfa_secret = None`
- Пользователь должен настроить MFA заново

### 8.6 Хранение секрета

- Секрет хранится в открытом виде в БД (это нормально для TOTP)
- Секрет уникален для каждого пользователя
- Если секрет утерян → пользователь не может войти (требуется сброс администратором)

---

## 9. Архитектура базы данных

### 9.1 Основные модели

#### User (Пользователь)
- Хранит учетные данные, MFA, роль, отдел
- Связи: `role`, `department`, `files`, `managed_department`

#### Role (Роль)
- Хранит разрешения в JSON
- Связи: `users` (многие пользователи имеют одну роль)

#### File (Файл)
- Метаданные файла, уровень доступа, статус VirusTotal
- Связи: `owner`, `department`, `encryption_key`, `shared_with`

#### FileAccess (Доступ к файлу)
- Явное предоставление доступа пользователю
- Связи: `file`, `user`

#### Department (Отдел)
- Иерархическая структура отделов
- Связи: `parent`, `children` (рекурсивная связь)

#### ExchangePolicy (Политика обмена)
- Правила обмена файлами между отделами
- Связи: `source_department`, `target_department`

#### EncryptionKey (Ключ шифрования)
- Зашифрованные ключи файлов
- Связи: `file` (через `encryption_key_id`)

#### AuditLog (Журнал аудита)
- Логи всех действий пользователей
- Связи: `user`

#### SecurityEvent (Событие безопасности)
- События безопасности, блокировки, подозрительная активность
- Связи: `user`, `acknowledged_by_user`

#### VirusTotalCache (Кэш VirusTotal)
- Кэш результатов проверки файлов
- Индекс по `sha256`

#### LoginAttempt (Попытка входа)
- Логирование всех попыток входа
- Используется для защиты от брутфорс-атак

#### UserSession (Сессия пользователя)
- Активные сессии пользователей
- Отслеживание IP, User-Agent, времени активности

#### Settings (Настройки)
- Глобальные настройки системы (например, `force_mfa`)

#### SecurityAlert (Настройки алертов)
- Правила для автоматических уведомлений

#### SecurityIncident (Инцидент безопасности)
- Группировка связанных событий

#### ConfigChangeLog (Журнал изменений конфигурации)
- Логи изменений ролей, отделов, настроек

### 9.2 Диаграмма связей

```
User
├── Role (many-to-one)
├── Department (many-to-one, department_id)
├── Department (many-to-one, managed_department_id)
└── File (one-to-many, owner_id)

File
├── User (many-to-one, owner_id)
├── Department (many-to-one, department_id)
├── EncryptionKey (many-to-one, encryption_key_id)
└── FileAccess (one-to-many, file_id)

FileAccess
├── File (many-to-one, file_id)
└── User (many-to-one, user_id)

Department
└── Department (self-reference, parent_id)

ExchangePolicy
├── Department (many-to-one, source_department_id)
└── Department (many-to-one, target_department_id)

EncryptionKey
└── File (one-to-one через encryption_key_id)

AuditLog
└── User (many-to-one, user_id)

SecurityEvent
├── User (many-to-one, user_id)
└── User (many-to-one, acknowledged_by)
```

---

## 10. Интеграция VirusTotal

### 10.1 Обзор

Система интегрирована с **VirusTotal API** для автоматической проверки всех загружаемых файлов на вирусы и вредоносное ПО.

### 10.2 Процесс проверки

1. **Вычисление хеша**
   - При загрузке файла вычисляется SHA-256 хеш

2. **Проверка кэша**
   - Система проверяет таблицу `VirusTotalCache` по хешу
   - Если файл уже проверялся → используется кэшированный результат

3. **Запрос к VirusTotal**
   - Если файла нет в кэше → отправляется запрос к VirusTotal API
   - Endpoint: `https://www.virustotal.com/vtapi/v2/file/report`
   - Параметры: `apikey`, `resource` (SHA-256)

4. **Обработка ответа**
   - `response_code == 0` → файл не найден, отправка файла на проверку
   - `response_code == 1` → результаты готовы:
     - `positives == 0` → `status = 'clean'`
     - `positives > 0` → `status = 'malicious'`
   - Ошибка API → `status = 'failed'`
   - Таймаут → `status = 'pending'`

5. **Сохранение результата**
   - Результат сохраняется в `VirusTotalCache`
   - Статус обновляется в `File.vt_status`

### 10.3 Статусы VirusTotal

| Статус | Описание | Доступ для скачивания |
|--------|----------|----------------------|
| `unscanned` | Файл еще не проверен | ❌ Запрещен |
| `pending` | Файл отправлен на проверку, ожидание результатов | ❌ Запрещен (временно) |
| `clean` | Файл чистый, вирусов не обнаружено | ✅ Разрешен |
| `malicious` | Обнаружены вирусы/вредоносное ПО | ❌ Запрещен навсегда |
| `failed` | Ошибка при проверке | ❌ Запрещен |
| `skipped` | Проверка пропущена (например, при отсутствии API-ключа) | ❌ Запрещен |

### 10.4 Обновление статуса

При попытке скачивания файла со статусом `pending`:
- Система автоматически запрашивает обновление статуса у VirusTotal
- Если статус изменился → обновляется в БД
- Если статус все еще `pending` → скачивание запрещено

### 10.5 Безопасность

- **Блокировка опасных файлов**: Файлы со статусом `malicious` никогда не могут быть скачаны
- **Логирование блокировок**: Все попытки скачать опасный файл логируются в `SecurityEvent`
- **Уведомление администраторов**: Критические события отправляются администраторам

### 10.6 Настройка API-ключа

API-ключ VirusTotal хранится в переменной окружения:
```bash
VT_API_KEY=your_api_key_here
```

Или в файле `KEY.env`:
```
VT_API_KEY=your_api_key_here
```

**Без API-ключа:**
- Проверка пропускается (`status = 'skipped'`)
- Файлы не могут быть скачаны до настройки API-ключа

---

## 11. Аудит и логирование

### 11.1 Журнал аудита (AuditLog)

**Назначение:** Запись всех действий пользователей в системе.

**Поля:**
- `user_id` — ID пользователя, выполнившего действие
- `action` — Тип действия (например, 'login', 'file_upload', 'file_download')
- `resource_type` — Тип ресурса ('file', 'user', 'role', и т.д.)
- `resource_id` — ID ресурса
- `ip_address` — IP-адрес пользователя
- `user_agent` — User-Agent браузера
- `timestamp` — Время действия (МСК)
- `details` — Дополнительная информация (JSON или текст)

**Типичные действия:**
- `login` — Вход в систему
- `logout` — Выход из системы
- `file_upload` — Загрузка файла
- `file_download` — Скачивание файла
- `file_share` — Предоставление доступа к файлу
- `file_delete` — Удаление файла
- `user_create` — Создание пользователя
- `user_update` — Обновление пользователя
- `role_update` — Изменение роли
- И другие...

### 11.2 События безопасности (SecurityEvent)

**Назначение:** Запись событий безопасности и подозрительной активности.

**Поля:**
- `user_id` — ID пользователя (nullable)
- `sha256` — Хеш файла (если связано с файлом)
- `filename` — Имя файла
- `event_type` — Тип события
- `details` — Детали события
- `severity` — Уровень серьезности: 'low', 'medium', 'high', 'critical'
- `ip_address` — IP-адрес
- `user_agent` — User-Agent
- `status` — Статус: 'new', 'acknowledged', 'resolved'
- `acknowledged_by` — ID администратора, подтвердившего событие
- `acknowledged_at` — Время подтверждения
- `resolved_at` — Время разрешения
- `created_at` — Время создания (МСК)

**Типичные события:**
- `virus_detected` — Обнаружен вирус в файле
- `blocked_download` — Блокировка скачивания опасного файла
- `bruteforce_attempt` — Попытка брутфорс-атаки
- `suspicious_login` — Подозрительный вход
- `unauthorized_access` — Несанкционированный доступ

### 11.3 Журнал изменений конфигурации (ConfigChangeLog)

**Назначение:** Отслеживание всех изменений конфигурации системы.

**Поля:**
- `changed_by` — ID администратора, внесшего изменение
- `change_type` — Тип изменения: 'role', 'permission', 'department', 'settings', 'user'
- `resource_type` — Тип ресурса
- `resource_id` — ID ресурса
- `resource_name` — Имя ресурса
- `field_name` — Имя измененного поля
- `old_value` — Старое значение
- `new_value` — Новое значение
- `ip_address` — IP-адрес
- `user_agent` — User-Agent
- `created_at` — Время изменения (МСК)
- `details` — Дополнительная информация

### 11.4 Логирование в файлы

Система также логирует в файлы через стандартный модуль `logging`:

**Файлы логов:**
- `logs/app.log` — Общий лог приложения
- `logs/security.log` — Лог событий безопасности

**Формат:** JSON (через `pythonjsonlogger`)

**Ротация:** Ротация файлов при достижении размера 10 МБ, сохраняется 5 резервных копий

### 11.5 Попытки входа (LoginAttempt)

**Назначение:** Отслеживание всех попыток входа для защиты от брутфорс-атак.

**Поля:**
- `username` — Имя пользователя
- `ip_address` — IP-адрес
- `success` — Успешность попытки (True/False)
- `timestamp` — Время попытки (МСК)
- `user_agent` — User-Agent
- `failure_reason` — Причина неудачи (если была)
- `user_id` — ID пользователя (если известен)

**Использование:**
- Подсчет неудачных попыток за период
- Блокировка IP или учетной записи при превышении лимита
- Уведомление администраторов о подозрительной активности

---

## 12. Администрирование

### 12.1 Админ-панель

Доступна по маршруту `/admin` для пользователей с разрешением `admin_access`.

**Основные разделы:**

#### 1. Статистика
- Количество пользователей
- Количество файлов
- Количество пользователей с MFA
- Количество записей аудита
- Размер хранилища (в МБ/ГБ)
- Статистика по типам файлов

#### 2. Заявки на регистрацию
- Список пользователей со статусом `pending`
- Кнопка для одобрения/отклонения
- Модальное окно с деталями заявки

#### 3. Управление пользователями (`/admin/users`)
- Таблица всех пользователей
- Фильтрация и поиск
- Редактирование пользователей
- Блокировка/разблокировка
- Сброс MFA

#### 4. Управление отделами
- Создание/редактирование отделов
- Иерархическая структура
- Назначение руководителей отделов

#### 5. Управление ролями
- Создание/редактирование ролей
- Назначение разрешений
- Русскоязычные названия разрешений

#### 6. Политики обмена файлами
- Создание правил обмена между отделами
- Разрешение/запрет отправки и просмотра

#### 7. Настройки безопасности
- Принудительное MFA для всех
- Другие настройки безопасности

#### 8. Журнал аудита (`/admin/audit`)
- Полный журнал всех действий пользователей
- Фильтрация по пользователю, типу действия, дате
- Экспорт в CSV/JSON

#### 9. События безопасности
- Список событий безопасности
- Фильтрация по серьезности, типу, статусу
- Подтверждение и разрешение инцидентов
- Экспорт в CSV/JSON

#### 10. Управление файлами (`/admin/files`)
- Просмотр всех файлов в системе
- Удаление файлов
- Просмотр метаданных

### 12.2 Управление пользователями

**Статусы пользователей:**
- `pending` — Ожидает одобрения администратора
- `active` — Активный пользователь
- `rejected` — Отклонен администратором
- `blocked` — Заблокирован

**Действия администратора:**
- Одобрение/отклонение заявок
- Изменение роли
- Назначение отдела
- Блокировка/разблокировка (`is_enabled`)
- Сброс MFA
- Сброс пароля (требует реализации)

### 12.3 Управление руководителями отделов

**Назначение руководителя:**
- В админ-панели при редактировании пользователя
- Поле `managed_department_id` указывает на отдел, которым управляет пользователь

**Права руководителя:**
- Просмотр пользователей своего отдела (`/department/users`)
- Изменение ролей (кроме 'admin')
- Блокировка/разблокировка пользователей отдела
- Сброс MFA для пользователей отдела

### 12.4 Экспорт данных

**Журнал аудита:**
- Экспорт в CSV
- Экспорт в JSON

**События безопасности:**
- Экспорт в CSV
- Экспорт в JSON

**Формат экспорта:**
- Все поля модели
- Форматирование дат
- Кодировка UTF-8

---

## Дополнительная информация

### Структура проекта

```
diplom/
├── app.py                    # Основное приложение Flask
├── config.py                 # Конфигурация (загрузка из .env)
├── KEY.env                   # Ключи шифрования и API (не в git!)
├── requirements.txt          # Зависимости Python
├── templates/                # HTML шаблоны
│   ├── base.html            # Базовый шаблон
│   ├── index.html           # Главная страница
│   ├── login.html           # Страница входа
│   ├── register.html        # Регистрация
│   ├── dashboard.html       # Панель пользователя
│   ├── admin.html           # Главная админ-панель
│   ├── admin_users.html     # Управление пользователями
│   ├── admin_audit.html     # Журнал аудита
│   ├── admin_files.html     # Управление файлами
│   ├── department_users.html # Пользователи отдела (для руководителей)
│   └── ...
├── static/                   # Статические файлы (CSS, JS)
├── uploads/                  # Зашифрованные файлы
├── logs/                     # Логи приложения
│   ├── app.log              # Общий лог
│   └── security.log         # Лог безопасности
└── secure_file_system.db    # База данных SQLite
```

### Переменные окружения

Создайте файл `KEY.env`:
```env
ENCRYPTION_KEY=your_gost_key_here (base64, 32 bytes для ГОСТ "Кузнечик")
VT_API_KEY=your_virustotal_api_key_here
```

**Генерация ENCRYPTION_KEY:**
```python
from gost_crypto import GOSTKuznyechik
import base64
key = GOSTKuznyechik.generate_key()
key_base64 = base64.urlsafe_b64encode(key).decode()
print(key.decode())  # Скопируйте это в KEY.env
```

### Часовой пояс

Система использует **московское время (UTC+3)**. Функция `moscow_now()` используется для всех записей времени в БД.

---

## Заключение

Данная система обеспечивает безопасный обмен файлами в корпоративной среде с использованием современных методов защиты:

- ✅ Шифрование файлов на уровне диска
- ✅ Многофакторная аутентификация
- ✅ Ролевая модель доступа
- ✅ Проверка файлов на вирусы
- ✅ Полное логирование действий
- ✅ Защита от брутфорс-атак
- ✅ Управление доступами на уровне отделов

Система готова к использованию в корпоративной среде и может быть расширена дополнительными функциями по мере необходимости.

---

**Версия документации:** 2.0  
**Дата обновления:** 2026  
**Автор:** Система безопасного обмена файлами
